import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'

export const dynamic = 'force-dynamic'
export const maxDuration = 300

// POST /api/cron/auto-schedule-maintenance
// Auto-schedule preventive maintenance based on installation dates and configuration
export async function GET(request: NextRequest) {
  const startTime = Date.now()

  try {
    console.log('ðŸ”§ Starting auto-schedule maintenance job...')

    // Get all active configs with autoSchedule enabled
    const configs = await prisma.maintenanceConfig.findMany({
      where: {
        autoSchedule: true,
        isActive: true,
      },
    })

    if (configs.length === 0) {
      return NextResponse.json({
        success: true,
        message: 'No active auto-schedule configs found',
        scheduled: 0,
      })
    }

    console.log(`Found ${configs.length} active auto-schedule configs`)

    let totalScheduled = 0

    // Get all solar systems with installation dates
    const solarSystems = await prisma.solarSystem.findMany({
      where: {
        isActive: true,
        installationDate: {
          not: null,
        },
      },
      include: {
        client: true,
        components: {
          include: {
            product: {
              include: {
                category: true,
              },
            },
          },
        },
      },
    })

    console.log(`Processing ${solarSystems.length} solar systems`)

    for (const system of solarSystems) {
      // Determine equipment type based on components
      const hasSolarPanels = system.components.some(
        (c) => c.product.category.name.toLowerCase().includes('panel')
      )
      const hasSolarHeater = system.components.some(
        (c) => c.product.category.name.toLowerCase().includes('calentador')
      )

      // Get appropriate config
      let config
      if (hasSolarPanels) {
        config = configs.find((c) => c.equipmentType === 'solar_panels')
      } else if (hasSolarHeater) {
        config = configs.find((c) => c.equipmentType === 'solar_heater')
      } else {
        config = configs.find((c) => c.equipmentType === 'general')
      }

      if (!config) {
        config = configs.find((c) => c.equipmentType === 'general')
      }

      if (!config) continue

      // Calculate next maintenance date based on installation date
      const installationDate = new Date(system.installationDate!)
      const today = new Date()
      const daysSinceInstallation = Math.floor(
        (today.getTime() - installationDate.getTime()) / (1000 * 60 * 60 * 24)
      )

      // Calculate how many maintenance cycles have passed
      const cyclesPassed = Math.floor(daysSinceInstallation / config.intervalDays)

      // Calculate next scheduled date
      const nextScheduledDate = new Date(installationDate)
      nextScheduledDate.setDate(
        installationDate.getDate() + (cyclesPassed + 1) * config.intervalDays
      )

      // Only schedule if next date is within notification window
      const daysUntilNext = Math.floor(
        (nextScheduledDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24)
      )

      if (daysUntilNext > config.notificationDaysBefore) {
        // Too early to schedule
        continue
      }

      if (daysUntilNext < -7) {
        // Too late (more than 7 days overdue), skip to avoid scheduling old maintenances
        continue
      }

      // Check if maintenance already exists for this date range
      const existingMaintenance = await prisma.maintenanceRecord.findFirst({
        where: {
          clientId: system.clientId,
          solarSystemId: system.id,
          type: 'PREVENTIVE',
          status: {
            in: ['PENDING_APPROVAL', 'SCHEDULED', 'IN_PROGRESS'],
          },
          scheduledDate: {
            gte: new Date(nextScheduledDate.getTime() - 7 * 24 * 60 * 60 * 1000), // 7 days before
            lte: new Date(nextScheduledDate.getTime() + 7 * 24 * 60 * 60 * 1000), // 7 days after
          },
        },
      })

      if (existingMaintenance) {
        console.log(
          `Maintenance already exists for ${system.systemName} on ${nextScheduledDate.toISOString()}`
        )
        continue
      }

      // Create maintenance record
      const maintenance = await prisma.maintenanceRecord.create({
        data: {
          clientId: system.clientId,
          solarSystemId: system.id,
          type: 'PREVENTIVE',
          priority: 'SCHEDULED',
          status: 'SCHEDULED',
          scheduledDate: nextScheduledDate,
          title: `Mantenimiento Preventivo - ${system.systemName}`,
          description: `Mantenimiento preventivo automÃ¡tico programado cada ${config.intervalDays} dÃ­as`,
          autoGenerated: true,
          nextScheduledDate: new Date(
            nextScheduledDate.getTime() + config.intervalDays * 24 * 60 * 60 * 1000
          ),
        },
      })

      // Create status history
      await prisma.maintenanceStatusHistory.create({
        data: {
          maintenanceId: maintenance.id,
          status: 'SCHEDULED',
          notes: 'Mantenimiento generado automÃ¡ticamente por el sistema',
          changedById: system.clientId, // Using client as default
        },
      })

      // Create notification for client
      await prisma.notification.create({
        data: {
          userId: system.clientId,
          title: 'Mantenimiento Programado',
          message: `Se ha programado un mantenimiento preventivo para ${system.systemName} el ${nextScheduledDate.toLocaleDateString('es-MX')}`,
          type: 'MAINTENANCE_SCHEDULED',
          relatedId: maintenance.id,
          read: false,
        },
      })

      totalScheduled++

      console.log(
        `âœ“ Scheduled maintenance for ${system.systemName} on ${nextScheduledDate.toISOString()}`
      )
    }

    const duration = Date.now() - startTime

    return NextResponse.json({
      success: true,
      message: `Auto-schedule completed successfully`,
      scheduled: totalScheduled,
      systemsProcessed: solarSystems.length,
      activeConfigs: configs.length,
      durationMs: duration,
    })
  } catch (error: any) {
    console.error('âŒ Error in auto-schedule maintenance:', error)

    return NextResponse.json(
      {
        success: false,
        error: error.message || 'Internal server error',
        durationMs: Date.now() - startTime,
      },
      { status: 500 }
    )
  }
}
